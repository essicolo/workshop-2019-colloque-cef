<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>3 Autoapprentissage compositionnel | Analyse de données compositionnelles, biostatistiques et autoapprentissage avec R</title>
  <meta name="description" content="Notes de conférence pour le 13ième Colloque du CEF">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="3 Autoapprentissage compositionnel | Analyse de données compositionnelles, biostatistiques et autoapprentissage avec R" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Notes de conférence pour le 13ième Colloque du CEF" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="3 Autoapprentissage compositionnel | Analyse de données compositionnelles, biostatistiques et autoapprentissage avec R" />
  
  <meta name="twitter:description" content="Notes de conférence pour le 13ième Colloque du CEF" />
  

<meta name="author" content="Serge-Étienne Parent">


<meta name="date" content="2019-05-01">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="les-biostats-compositionnelles.html">
<link rel="next" href="liens-utiles.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> L’analyse compositionnelle</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#contexte"><i class="fa fa-check"></i><b>1.1</b> Contexte</a></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#les-donnees-compositionnelles"><i class="fa fa-check"></i><b>1.2</b> Les données compositionnelles</a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#les-transformations-compositionnelles"><i class="fa fa-check"></i><b>1.3</b> Les transformations compositionnelles</a></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html#les-zeros"><i class="fa fa-check"></i><b>1.4</b> Les zéros</a><ul>
<li class="chapter" data-level="1.4.1" data-path="index.html"><a href="index.html#les-zeros-arrondis"><i class="fa fa-check"></i><b>1.4.1</b> Les zéros arrondis</a></li>
<li class="chapter" data-level="1.4.2" data-path="index.html"><a href="index.html#les-decomptes-de-zero"><i class="fa fa-check"></i><b>1.4.2</b> Les décomptes de zéro</a></li>
<li class="chapter" data-level="1.4.3" data-path="index.html"><a href="index.html#les-zeros-structurels"><i class="fa fa-check"></i><b>1.4.3</b> Les zéros structurels</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="les-biostats-compositionnelles.html"><a href="les-biostats-compositionnelles.html"><i class="fa fa-check"></i><b>2</b> Les biostats compositionnelles</a></li>
<li class="chapter" data-level="3" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html"><i class="fa fa-check"></i><b>3</b> Autoapprentissage compositionnel</a><ul>
<li class="chapter" data-level="3.1" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#lexique"><i class="fa fa-check"></i><b>3.1</b> Lexique</a></li>
<li class="chapter" data-level="3.2" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#demarche"><i class="fa fa-check"></i><b>3.2</b> Démarche</a><ul>
<li class="chapter" data-level="3.2.1" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#pretraitement"><i class="fa fa-check"></i><b>3.2.1</b> Prétraitement</a></li>
<li class="chapter" data-level="3.2.2" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#entrainement-et-test"><i class="fa fa-check"></i><b>3.2.2</b> Entraînement et test</a></li>
<li class="chapter" data-level="3.2.3" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#validation-croisee"><i class="fa fa-check"></i><b>3.2.3</b> Validation croisée</a></li>
<li class="chapter" data-level="3.2.4" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#choix-de-lalgorithme-dapprentissage"><i class="fa fa-check"></i><b>3.2.4</b> Choix de l’algorithme d’apprentissage</a></li>
<li class="chapter" data-level="3.2.5" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#deploiement"><i class="fa fa-check"></i><b>3.2.5</b> Déploiement</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#en-resume"><i class="fa fa-check"></i><b>3.3</b> En résumé,</a></li>
<li class="chapter" data-level="3.4" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#lautoapprentissage-en-r"><i class="fa fa-check"></i><b>3.4</b> L’autoapprentissage en R</a></li>
<li class="chapter" data-level="3.5" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#les-k-plus-proches-voisins"><i class="fa fa-check"></i><b>3.5</b> Les <em>k</em> plus proches voisins</a><ul>
<li class="chapter" data-level="3.5.1" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#exemple-dapplication"><i class="fa fa-check"></i><b>3.5.1</b> Exemple d’application</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#les-processus-gaussiens"><i class="fa fa-check"></i><b>3.6</b> Les processus gaussiens</a><ul>
<li class="chapter" data-level="3.6.1" data-path="autoapprentissage-compositionnel.html"><a href="autoapprentissage-compositionnel.html#exemple-dapplication-1"><i class="fa fa-check"></i><b>3.6.1</b> Exemple d’application</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="liens-utiles.html"><a href="liens-utiles.html"><i class="fa fa-check"></i><b>4</b> Liens utiles</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Analyse de données compositionnelles, biostatistiques et autoapprentissage avec R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="autoapprentissage-compositionnel" class="section level1">
<h1><span class="header-section-number">3</span> Autoapprentissage compositionnel</h1>
<p>On peut lier les données compositionnelles avec une ou plusieurs autres à l’aide de régressions linéaires, polynomiales, sinusoïdales, exponentielle, sigmoïdales, <a href="https://dl.sciencesocieties.org/publications/aj/pdfs/107/2/786">etc</a>. Encore faut-il s’assurer que ces formes préétablies représentent le phénomène de manière fiable. Lorsque la forme de la réponse est difficile à envisager, en particulier dans des cas non-linéaires ou impliquant plusieurs variables, on pourra faire appel à des modèles dont la structure n’est pas contrôlée par une équation rigide gouvernée par des paramètres (comme la pente ou l’intercept). L’<strong>autoapprentissage</strong> vise à détecter des structures complexes émergeant d’ensembles de données à l’aide des mathématiques et de processus automatisés afin de <strong>prédire</strong> l’émergence de futures occurrences.</p>
<div id="lexique" class="section level2">
<h2><span class="header-section-number">3.1</span> Lexique</h2>
<p>L’autoapprentissage possède son jargon particulier. Les variables <strong>réponse</strong> sont celles que nous comptons prédire, alors que les variables d’<strong>entrée</strong> sont utilisées pour prédire une réponse. Alors que l’<strong>apprentissage supervisé</strong> inclue une variable réponse, l’<strong>apprentissage non-supervisé</strong>, lui, n’en a pas: il est surtout utilisé pour créer des catégories à partir de données qui ne sont pas préalablement étiquettées. Les apprentissages par <strong>régression</strong> prédisent des variables continuent alors que les apprentissage par <strong>classification</strong> prédisent des catégories. Les <strong>données d’entraînement</strong> servent à ajuster le modèle alors que les <strong>données de test</strong> servent à évaluer sa performance.</p>
</div>
<div id="demarche" class="section level2">
<h2><span class="header-section-number">3.2</span> Démarche</h2>
<div id="pretraitement" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Prétraitement</h3>
<p>Pour la plupart des techniques d’autoapprentissage, le choix de l’échelle de mesure est déterminant sur la modélisation subséquente. Par exemple, un algorithme basé sur la distance comme les <em>k</em> plus proches voisins ne mesurera pas les mêmes distances entre deux observations si l’on change l’unité de mesure d’une variable du mètre au kilomètre. En outre, les transformations compositionnelles sont une forme de prétraitement.</p>
</div>
<div id="entrainement-et-test" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Entraînement et test</h3>
<p>Un modèle prut fonctionner très bien en terrain connu, mais une prédiction doit être évaluée sur des données pour lesquelles le modèle ne connait pas la réponse. En pratique, il faut séparer un tableau de données en deux: un tableau d’entraînement et un tableau de test. Il n’existe pas de standards sur la proportion à utiliser dans l’un et l’autre. Rarement, toutefois, réservera-t-on moins plus de 50% et moins de 20% à la phase de test. Dans tous les cas, on doit porter une attention particulière à l’équilibre des données dans chaque tableau (les distributions devraient être semblables). L’analyste doit s’assurer de séparer le tableau au hasard pour ne pas biaiser le modèle, mais de manière consciencieuse pour éviter d’évacuer des cas rares dans un tableau ou dans l’autre.</p>
</div>
<div id="validation-croisee" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Validation croisée</h3>
<p>Lorsque l’on considère une structure comme du bruit, on est dans un cas de sousapprentissage. Lorsque, au contraire, on interprète du bruit comme une structure, on est en cas de surapprentissage. Une manière de limiter le <em>mésapprentissage</em> est d’avoir recours à la validation croisée. La validation croisée est un principe incluant plusieurs algorithmes qui consiste à entraîner le modèle sur un échantillonnage aléatoire des données d’entraînement. La technique la plus utilisée est le <em>k-fold</em>, où l’on sépare aléatoirement le tableau d’entraînement en un nombre <em>k</em> de tableaux. À chaque étape de la validation croisée, on calibre le modèle sur tous les tableaux sauf un, puis on valide le modèle sur le tableau exclu.</p>
</div>
<div id="choix-de-lalgorithme-dapprentissage" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Choix de l’algorithme d’apprentissage</h3>
<p>Choisir l’algorithme (ou les algorithmes) adéquats pour votre problème n’est pas une tâche facile. Ce choix sera motivé par le problème à régler, les tenants et aboutissants des algorithmes, votre expérience, l’expérience de la littérature, l’expérience de vos collègues, etc. Ce serait peu productif d’étudier la mathématique de chacun d’eux. Une approche raisonnable est de tester plusieurs modèles, de retenir les modèles qui semblent les plus pertinents, et d’approfondir si ce n’est déjà fait la mathématique des options retenues et d’apprendre à les maîtriser au fil de vos expériences. Le module <strong><code>scikit-learn</code></strong>, qui fonctionne en langage Python, propose néanmoins un schéma décisionnel.</p>
<div class="figure" style="text-align: center"><span id="fig:ml-map"></span>
<img src="images/00_ml_map.png" alt="Schéma décisionnel des algorithmes pertinents. Source: [scikit-learn](https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html)." width="100%" />
<p class="caption">
Figure 3.1: Schéma décisionnel des algorithmes pertinents. Source: <a href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html">scikit-learn</a>.
</p>
</div>
</div>
<div id="deploiement" class="section level3">
<h3><span class="header-section-number">3.2.5</span> Déploiement</h3>
<p>Nous ne couvrirons pas la phase de déploiement d’un modèle. Notons seulement qu’il est possible, en R, d’exporter un modèle dans un fichier <code>.Rdata</code>, qui pourra être chargé dans un autre environnement R. Cet environnement peut être une feuille de calcul comme une interface visuelle montée par exemple avec <a href="https://shiny.rstudio.com/">Shiny</a>.</p>
</div>
</div>
<div id="en-resume" class="section level2">
<h2><span class="header-section-number">3.3</span> En résumé,</h2>
<ol style="list-style-type: decimal">
<li>Explorer les données</li>
<li>Sélectionner des algorithmes</li>
<li>Effectuer un prétraitement</li>
<li>Créer un ensemble d’entraînement et un ensemble de test</li>
<li>Lisser les données sur les données d’entraînement avec validation croisée</li>
<li>Tester le modèle</li>
<li>Déployer le modèle</li>
</ol>
</div>
<div id="lautoapprentissage-en-r" class="section level2">
<h2><span class="header-section-number">3.4</span> L’autoapprentissage en R</h2>
<p>Plusieurs options sont disponibles. Je vais introduire le module <strong><code>caret</code></strong> de R a été conçu pour donner accès à des centaines de fonctions d’autoapprentissage via une interface commune.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;tidyverse&quot;</span>)
<span class="kw">library</span>(<span class="st">&quot;compositions&quot;</span>)
<span class="kw">library</span>(<span class="st">&quot;caret&quot;</span>)</code></pre>
<p>Pour cet atelier, nous allons couvrir les <em>k</em> plus proches voisins et les processus gaussiens.</p>
</div>
<div id="les-k-plus-proches-voisins" class="section level2">
<h2><span class="header-section-number">3.5</span> Les <em>k</em> plus proches voisins</h2>
<p>Le principe des KNN (<em>k-nearest neighbors</em>: un objet va ressembler à ce qui se trouve dans son voisinage.</p>
<p><img src="https://media.giphy.com/media/4esrzplOvKkE0/giphy.gif" style="display: block; margin: auto;" /></p>
<p>Les KNN se basent en effet sur une métrique de distance pour rechercher un nombre <em>k</em> de points situés à proximité de la mesure. Les <em>k</em> points les plus proches sont retenus, <em>k</em> étant un entier non nul à optimiser. Un autre paramètre parfois utilisé est la distance maximale des voisins à considérer: un voisin trop éloigné pourra être discarté. La réponse attribuée à la mesure est calculée à partir de la réponse des <em>k</em> voisins retenus. Dans le cas d’une régression, on utiliser généralement la moyenne. Dans le cas de la classification, la mesure prendra la catégorie qui sera la plus présente chez les <em>k</em> plus proches voisins. La métrique de distance devient importante et une standardisation des données (par exemple soustraire la moyenne, puis diviser par l’écart-type) est généralement nécessaire en prétraitement. Pour ce qui est des données compositionnelles, on pourra tirer profit de la métrique d’Aitchison en calculant les distances euclidienne sur des données transformées par <em>clr</em> ou <em>ilr</em>.</p>
<div id="exemple-dapplication" class="section level3">
<h3><span class="header-section-number">3.5.1</span> Exemple d’application</h3>
<p>L’ionome foliaire est la concentration en éléments d’une feuille: ce sont des données compositionnelles. Nous allons prédire une espèce fictive à partir de son ionome seulement (si d’autres variables étaient intégrées à la prédiction, il faudrait standardiser les données).</p>
<pre class="sourceCode r"><code class="sourceCode r">veggies &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/legumes_fictifs.csv&quot;</span>)
<span class="kw">head</span>(veggies)</code></pre>
<pre><code>## # A tibble: 6 x 7
##   Culture   Annee     N     P     K    Ca    Mg
##   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 PanetRave  2007  3.13  0.36  5.33  1.96  0.36
## 2 PanetRave  2007  3.03  0.37  4.94  2.33  0.4 
## 3 PanetRave  2007  3.01  0.36  5.08  1.76  0.36
## 4 PanetRave  2007  3.53  0.36  5.44  2.13  0.37
## 5 PanetRave  2007  3.96  0.38  6.1   2.76  0.5 
## 6 PanetRave  2007  3.9   0.38  6.06  2.66  0.48</code></pre>
<p>Effectuons un prétraitement compositionnel sous forme d’<em>ilr</em>.</p>
<pre class="sourceCode r"><code class="sourceCode r">veggies &lt;-<span class="st"> </span>veggies <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">Fv =</span> <span class="dv">100</span> <span class="op">-</span><span class="st"> </span>(N<span class="op">+</span>P<span class="op">+</span>K<span class="op">+</span>Ca<span class="op">+</span>Mg))
sbp &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,
                <span class="dv">1</span>, <span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>,
                <span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
                <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>,
                <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), <span class="dt">ncol =</span> <span class="dv">6</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
veggies_ilr &lt;-<span class="st"> </span>veggies <span class="op">%&gt;%</span>
<span class="st">  </span>dplyr<span class="op">::</span><span class="kw">select</span>(N, P, K, Ca, Mg, Fv) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ilr</span>(., <span class="dt">V =</span> <span class="kw">gsi.buildilrBase</span>(<span class="kw">t</span>(sbp))) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">as_tibble</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">Culture =</span> veggies<span class="op">$</span>Culture)</code></pre>
<p>Séparons les données en entraînement (<code>_tr</code>) et en test (<code>_te</code>) en utilisant la fonction <code>caret::createDataPartition</code> avec une proportion 70/30 (<code>p = 0.7</code>). Il est essentiel d’utiliser <code>set.seed()</code> pour s’assurer que la partition soit la même à chaque session de code (pour la reproductibilité) - j’ai l’habitude de taper n’importe quel numéro à environ 6 chiffres, mais lors de publications, je vais sur <a href="https://www.random.org/">random.org</a> et je génère un numéro au hasard, sans biais.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">68017</span>)
id_tr &lt;-<span class="st"> </span><span class="kw">createDataPartition</span>(veggies_ilr<span class="op">$</span>Culture, <span class="dt">p =</span> <span class="fl">0.7</span>, <span class="dt">list =</span> <span class="ot">FALSE</span>)
veggies_tr &lt;-<span class="st"> </span>veggies_ilr[id_tr, ]
veggies_te &lt;-<span class="st"> </span>veggies_ilr[<span class="op">-</span>id_tr, ]</code></pre>
<p>L’objet <code>id_tr</code> comprend les indices de ligne des données d’entraînement. Avant de lancer nos calculs, allons vois sur la <a href="https://topepo.github.io/caret/available-models.html">page de caret</a> les modules qui effectuent des KNN pour la classification. Nous trouvons <strong><code>knn</code></strong> et <strong><code>kknn</code></strong>. Prenons <strong><code>kknn</code></strong>. Nous pourrions utiliser une grille de paramètre pour l’optimisation du modèle, mais laissons <strong><code>caret</code></strong> générer une grille par défaut. Nous allons néamoins modéliser avec une validation croisée à 5 plis.</p>
<pre class="sourceCode r"><code class="sourceCode r">ctrl &lt;-<span class="st"> </span><span class="kw">trainControl</span>(<span class="dt">method=</span><span class="st">&quot;repeatedcv&quot;</span>, <span class="dt">repeats =</span> <span class="dv">5</span>)</code></pre>
<p>Pour finalement lisser le modèle.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">8961704</span>)
clf &lt;-<span class="st"> </span><span class="kw">train</span>(Culture <span class="op">~</span><span class="st"> </span>.,
             <span class="dt">data =</span> veggies_tr,
             <span class="dt">method =</span> <span class="st">&quot;kknn&quot;</span>,
             <span class="dt">trainControl =</span> ctrl)
clf</code></pre>
<pre><code>## k-Nearest Neighbors 
## 
## 342 samples
##   5 predictor
##   4 classes: &#39;ChouMarseille&#39;, &#39;Courgine&#39;, &#39;PanetRave&#39;, &#39;PommeMer&#39; 
## 
## No pre-processing
## Resampling: Bootstrapped (25 reps) 
## Summary of sample sizes: 342, 342, 342, 342, 342, 342, ... 
## Resampling results across tuning parameters:
## 
##   kmax  Accuracy   Kappa    
##   5     0.9738582  0.9647107
##   7     0.9738582  0.9647107
##   9     0.9738582  0.9647107
## 
## Tuning parameter &#39;distance&#39; was held constant at a value of 2
## 
## Tuning parameter &#39;kernel&#39; was held constant at a value of optimal
## Accuracy was used to select the optimal model using the largest value.
## The final values used for the model were kmax = 9, distance = 2 and
##  kernel = optimal.</code></pre>
<p>Nous obtenons les paramètres du modèle optimal. Prédisons l’espèce selon son ionome pour chacun des tableaux.</p>
<pre class="sourceCode r"><code class="sourceCode r">pred_tr &lt;-<span class="st"> </span><span class="kw">predict</span>(clf)
pred_te &lt;-<span class="st"> </span><span class="kw">predict</span>(clf, <span class="dt">newdata =</span> veggies_te)</code></pre>
<p>Une manière d’évaluer la prédiction est d’afficher un tableau de contingence.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="dt">Observed =</span> veggies_tr<span class="op">$</span>Culture, <span class="dt">Predicted =</span> pred_tr)</code></pre>
<pre><code>##                Predicted
## Observed        ChouMarseille Courgine PanetRave PommeMer
##   ChouMarseille            67        0         0        0
##   Courgine                  0       95         0        0
##   PanetRave                 0        0       101        0
##   PommeMer                  0        0         0       79</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="dt">Observed =</span> veggies_te<span class="op">$</span>Culture, <span class="dt">Predicted =</span> pred_te)</code></pre>
<pre><code>##                Predicted
## Observed        ChouMarseille Courgine PanetRave PommeMer
##   ChouMarseille            27        0         1        0
##   Courgine                  0       40         0        0
##   PanetRave                 3        0        39        0
##   PommeMer                  0        0         0       33</code></pre>
<p>Les espèces sont toutes classées en entraînement, mais quelques rares erreurs surviennent en test. Pas mal comme classement!</p>
<p><img src="https://media.giphy.com/media/KxVA4LQTFJp7y/giphy.gif" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="les-processus-gaussiens" class="section level2">
<h2><span class="header-section-number">3.6</span> Les processus gaussiens</h2>
<p>Les prédictions que nous avons obtenues des KNN sont des catégories, mais on aurait pu aussi prédire des nombres réels. Dans les cas où la crédibilité de la réponse est importante, il devient pertinent que la sortie soit probabiliste: les prédictions seront alors présentées sous forme de distributions de probabilité. Les <strong>processus gaussiens</strong> snt en mesure de prédire des distributions (prédictions probabilistes).</p>
<p>Le principe des processus gaussiens (<em>gaussian processes</em>, GP) est de générer une distribution multinormale (comprenant théoriquement une infinité de dimensions) à l’aide d’une matrice de covariance qui doit être définie (que l’on nomme le noyau) et d’un vecteur de moyenne (normalement composés de zéros pour une variable-réponse centrée), puis d’en sortir une distribution a posteriori conditionnée sur les observations. Les GP sont semblables à la modélisation de la variance courrament utilisée en géostatistiques. Pour plus de détails, référez-vous aux notes du cours <a href="https://essicolo.github.io/ecologie-mathematique-R/chapitre-ml.html"><em>Anayse et modélisation d’agroécosystèmes</em></a>. Pour l’instant, retenez que (1) la matrice de covariance a une influence capitale et que (2) vous devez préférablement standardiser (centrer et réduire) vos entrées et nécessairement vos réponses.</p>
<div id="exemple-dapplication-1" class="section level3">
<h3><span class="header-section-number">3.6.1</span> Exemple d’application</h3>
<p>Les données de pollution en métaux lourds sur une rive de la rivière Meuse, en France, sont souvent utilisées pour les exemples d’application en prédiction spatiale. Nous allons utiliser les processus gaussiens (avec le module <strong><code>kernlab</code></strong>) pour prédire les <em>ilr</em> des métaux lourds à partir des coordonnées et de la distance de la rivière, en profitant de l’occasion pour cartographier avec les modules <strong><code>ggmap</code></strong> et <strong><code>sf</code></strong>. Notez que les ilr sont ici les variables-réponse, alors qu’ils étaient les variables d’entrée dans l’exemple précédent avec les KNN.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;ggmap&quot;</span>)
<span class="kw">library</span>(<span class="st">&quot;sf&quot;</span>)
meuse &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/meuse.csv&quot;</span>)
meuse <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">head</span>()</code></pre>
<pre><code>## # A tibble: 6 x 14
##        x      y cadmium copper  lead  zinc  elev    dist    om ffreq  soil
##    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 181072 333611    11.7     85   299  1022  7.91 0.00136  13.6     1     1
## 2 181025 333558     8.6     81   277  1141  6.98 0.0122   14       1     1
## 3 181165 333537     6.5     68   199   640  7.8  0.103    13       1     1
## 4 181298 333484     2.6     81   116   257  7.66 0.190     8       1     2
## 5 181307 333330     2.8     48   117   269  7.48 0.277     8.7     1     2
## 6 181390 333260     3       61   137   281  7.79 0.364     7.8     1     2
## # ... with 3 more variables: lime &lt;dbl&gt;, landuse &lt;chr&gt;, dist.m &lt;dbl&gt;</code></pre>
<p>Les coordonnées sont exprimées en format néerlandais <a href="https://epsg.io/28992"><em>EPSG:28992</em></a>. Transformons-les en longitudes et latitudes sur l’ellipsoïde NAD83 avec le module <strong><code>sf</code></strong>.</p>
<pre class="sourceCode r"><code class="sourceCode r">meuse_geo &lt;-<span class="st"> </span>meuse <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">st_as_sf</span>(<span class="dt">coords =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>), <span class="dt">crs =</span> <span class="dv">28992</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">st_transform</span>(<span class="st">&quot;+proj=longlat +datum=NAD83&quot;</span>)
meuse_coord &lt;-<span class="st"> </span>meuse_geo <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">st_coordinates</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">as_tibble</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">cadmium =</span> meuse<span class="op">$</span>cadmium,
         <span class="dt">copper =</span> meuse<span class="op">$</span>copper,
         <span class="dt">lead =</span> meuse<span class="op">$</span>lead,
         <span class="dt">zinc =</span> meuse<span class="op">$</span>zinc,
         <span class="dt">dist =</span> meuse<span class="op">$</span>dist) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">rename</span>(<span class="dt">x =</span> <span class="st">&quot;X&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;Y&quot;</span>)
meuse_coord <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">head</span>()</code></pre>
<pre><code>## # A tibble: 6 x 7
##       x     y cadmium copper  lead  zinc    dist
##   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1  5.76  51.0    11.7     85   299  1022 0.00136
## 2  5.76  51.0     8.6     81   277  1141 0.0122 
## 3  5.76  51.0     6.5     68   199   640 0.103  
## 4  5.76  51.0     2.6     81   116   257 0.190  
## 5  5.76  51.0     2.8     48   117   269 0.277  
## 6  5.76  51.0     3       61   137   281 0.364</code></pre>
<p>À partir des coordonnées, nous pouvons grâce à <code>ggmap::get_stamenmap</code> effectuer une requête pour télécherger les tuiles d’un fond de carte, sur lesquels nous affichons nous concentrations en zinc.</p>
<pre class="sourceCode r"><code class="sourceCode r">meuse_map &lt;-<span class="st"> </span><span class="kw">get_stamenmap</span>(<span class="dt">bbox =</span> <span class="kw">c</span>(<span class="dt">left =</span> <span class="fl">5.716</span>, <span class="dt">right =</span> <span class="fl">5.767</span>, <span class="dt">bottom =</span> <span class="fl">50.95</span>, <span class="dt">top =</span> <span class="dv">51</span>),
                           <span class="dt">zoom =</span> <span class="dv">14</span>, <span class="dt">maptype =</span> <span class="st">&quot;terrain&quot;</span>)
<span class="kw">ggmap</span>(meuse_map) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> meuse_coord, <span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">fill =</span> zinc), <span class="dt">shape =</span> <span class="dv">21</span>, <span class="dt">size =</span> <span class="dv">2</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_fill_viridis_c</span>(<span class="dt">option =</span> <span class="st">&quot;inferno&quot;</span>, <span class="dt">direction =</span> <span class="dv">-1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>()</code></pre>
<div class="figure" style="text-align: center"><span id="fig:map-zinc-observations"></span>
<img src="_main_files/figure-html/map-zinc-observations-1.png" alt="Mesures de concentration en zinc dans les sols d'une rive de la rivière Meuse" width="100%" />
<p class="caption">
Figure 3.2: Mesures de concentration en zinc dans les sols d’une rive de la rivière Meuse
</p>
</div>
<p>Transformons maintenant nos concentrations en <em>ilr</em>.</p>
<pre class="sourceCode r"><code class="sourceCode r">sbp &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,
                <span class="dv">1</span>, <span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>,
                <span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
                <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>),
              <span class="dt">ncol =</span> <span class="dv">5</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
psi &lt;-<span class="st"> </span><span class="kw">gsi.buildilrBase</span>(<span class="kw">t</span>(sbp))

meuse_ilr &lt;-<span class="st"> </span>meuse <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">Fv =</span> <span class="fl">1e6</span> <span class="op">-</span><span class="st"> </span>cadmium <span class="op">-</span><span class="st"> </span>copper <span class="op">-</span><span class="st"> </span>lead <span class="op">-</span><span class="st"> </span>zinc) <span class="op">%&gt;%</span>
<span class="st">  </span>dplyr<span class="op">::</span><span class="kw">select</span>(cadmium, copper, lead, zinc, Fv) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">acomp</span>(.) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ilr</span>(., <span class="dt">V =</span> psi) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">as_tibble</span>()

<span class="kw">names</span>(meuse_ilr) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;CdCuPbZn.Fv&quot;</span>,
                      <span class="st">&quot;CdCu.PbZn&quot;</span>,
                      <span class="st">&quot;Cd.Cu&quot;</span>,
                      <span class="st">&quot;Pb.Zn&quot;</span>)

meuse_ilr <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">head</span>()</code></pre>
<pre><code>## # A tibble: 6 x 4
##   CdCuPbZn.Fv CdCu.PbZn Cd.Cu  Pb.Zn
##         &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1       -7.99     -2.86 -1.40 -0.869
## 2       -8.06     -3.06 -1.59 -1.00 
## 3       -8.37     -2.83 -1.66 -0.826
## 4       -8.86     -2.48 -2.43 -0.562
## 5       -8.94     -2.73 -2.01 -0.589
## 6       -8.83     -2.67 -2.13 -0.508</code></pre>
<p>Ces données sont jumelées avec les coordonnées et la distance de la rivière pour créer un tableau prêt pour l’autoapprentissage.</p>
<pre class="sourceCode r"><code class="sourceCode r">meuse_ml &lt;-<span class="st"> </span>meuse_coord <span class="op">%&gt;%</span>
<span class="st">  </span>dplyr<span class="op">::</span><span class="kw">select</span>(x, y, dist) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">bind_cols</span>(meuse_ilr)</code></pre>
<p>Puis, séparons les données.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1046584</span>)
train_id &lt;-<span class="st"> </span><span class="kw">createDataPartition</span>(meuse<span class="op">$</span>y, <span class="dt">p=</span><span class="fl">0.7</span>, <span class="dt">list=</span><span class="ot">FALSE</span>)<span class="co"># #pour obtenir un équilibre sur les latitudes</span>
meuse_tr &lt;-<span class="st"> </span>meuse_ml[train_id, ]
meuse_te &lt;-<span class="st"> </span>meuse_ml[<span class="op">-</span>train_id, ]</code></pre>
<p>Bien que l’autoapprentissage sera effectué avec <strong><code>caret</code></strong>, vous aurez avantage à prendre davantage de contrôle sur les processus gaussiens en utilisant directement la fonction <code>kernlab::gausspr()</code>, qui permettra du coup de prédire l’incertitude de la prédiction. Notez toutefois que R ne possède toujours pas de module polyvalent pour les processus gaussiens, ce qui me motive habituellement à <a href="https://scikit-learn.org/stable/modules/gaussian_process.html">basculer en Python</a> à cette étape. Continuons néanmoins avec R, en sélectionnant un noyau de type radial que nous ne tenterons pas d’optimiser et sur lesquels nous laissons tomber la validation croisée pour éviter de compliquer l’exemple. Enfin, notez les données sont dans ce cas-ci mises automatiquement à l’échelle.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">4896378</span>)
mod_CdCuPbZn.Fv &lt;-<span class="st"> </span><span class="kw">train</span>(CdCuPbZn.Fv <span class="op">~</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y <span class="op">+</span><span class="st"> </span>dist,
                         <span class="dt">data =</span> meuse_tr,
                         <span class="dt">method =</span> <span class="st">&quot;knn&quot;</span>)
mod_CdCu.PbZn &lt;-<span class="st"> </span><span class="kw">train</span>(CdCu.PbZn <span class="op">~</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y <span class="op">+</span><span class="st"> </span>dist,
                         <span class="dt">data =</span> meuse_tr,
                         <span class="dt">method =</span> <span class="st">&quot;gaussprRadial&quot;</span>)
mod_Cd.Cu &lt;-<span class="st"> </span><span class="kw">train</span>(Cd.Cu <span class="op">~</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y <span class="op">+</span><span class="st"> </span>dist,
                         <span class="dt">data =</span> meuse_tr,
                         <span class="dt">method =</span> <span class="st">&quot;gaussprRadial&quot;</span>)
mod_Pb.Zn&lt;-<span class="st"> </span><span class="kw">train</span>(Pb.Zn <span class="op">~</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y <span class="op">+</span><span class="st"> </span>dist,
                         <span class="dt">data =</span> meuse_tr,
                         <span class="dt">method =</span> <span class="st">&quot;gaussprRadial&quot;</span>)</code></pre>
<p>Effectuons la série de prédictions en remettant le tout dans l’échelle originale.</p>
<pre class="sourceCode r"><code class="sourceCode r">pred1_tr &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_CdCuPbZn.Fv)
pred1_te &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_CdCuPbZn.Fv, <span class="dt">newdata =</span> meuse_te)
pred2_tr &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_CdCu.PbZn)
pred2_te &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_CdCu.PbZn, <span class="dt">newdata =</span> meuse_te)
pred3_tr &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_Cd.Cu)
pred3_te &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_Cd.Cu, <span class="dt">newdata =</span> meuse_te)
pred4_tr &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_Pb.Zn)
pred4_te &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_Pb.Zn, <span class="dt">newdata =</span> meuse_te)</code></pre>
<p>Nous pouvons évaluer notre modèle en comparant les prédictions.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">2</span>))
<span class="kw">plot</span>(meuse_tr<span class="op">$</span>CdCuPbZn.Fv, pred1_tr, <span class="dt">main =</span> <span class="st">&quot;Train&quot;</span>) ; <span class="kw">abline</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
<span class="kw">plot</span>(meuse_te<span class="op">$</span>CdCuPbZn.Fv, pred1_te, <span class="dt">main =</span> <span class="st">&quot;Test&quot;</span>) ; <span class="kw">abline</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
<span class="kw">plot</span>(meuse_tr<span class="op">$</span>CdCu.PbZn, pred2_tr, <span class="dt">main =</span> <span class="st">&quot;Train&quot;</span>) ; <span class="kw">abline</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
<span class="kw">plot</span>(meuse_te<span class="op">$</span>CdCu.PbZn, pred2_te, <span class="dt">main =</span> <span class="st">&quot;Test&quot;</span>) ; <span class="kw">abline</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
<span class="kw">plot</span>(meuse_tr<span class="op">$</span>Cd.Cu, pred3_tr, <span class="dt">main =</span> <span class="st">&quot;Train&quot;</span>) ; <span class="kw">abline</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
<span class="kw">plot</span>(meuse_te<span class="op">$</span>Cd.Cu, pred3_te, <span class="dt">main =</span> <span class="st">&quot;Test&quot;</span>) ; <span class="kw">abline</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
<span class="kw">plot</span>(meuse_tr<span class="op">$</span>Pb.Zn, pred4_tr, <span class="dt">main =</span> <span class="st">&quot;Train&quot;</span>) ; <span class="kw">abline</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
<span class="kw">plot</span>(meuse_te<span class="op">$</span>Pb.Zn, pred4_te, <span class="dt">main =</span> <span class="st">&quot;Test&quot;</span>) ; <span class="kw">abline</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:inspection-pred-gp"></span>
<img src="_main_files/figure-html/inspection-pred-gp-1.png" alt="Évaluation visuelle de la prédiction spatiale par processus gaussien" width="100%" />
<p class="caption">
Figure 3.3: Évaluation visuelle de la prédiction spatiale par processus gaussien
</p>
</div>
<p>Les résultats montrent que les modèles ne sont pas exceptionnels, et qu’une optimisation critique et conscientieuse devrait être effectuée en vue d’obtenir de meilleures prédictions. Continuons néanmoins.</p>
<p>La prédiction spatiale demande une grille comprenant des points sur lesquels on voudra effectuer des prédictions. Il est possible d’en créer une de différentes manières <a href="https://essicolo.github.io/ecologie-mathematique-R/chapitre-geo.html#manipuler-des-tableaux-sf">en R</a> ou dans des systèmes d’information géographique. Dans ce cas, elle est disponible en format csv.</p>
<pre class="sourceCode r"><code class="sourceCode r">meuse_grid &lt;-<span class="st">  </span><span class="kw">read_csv</span>(<span class="st">&quot;data/meuse_grid.csv&quot;</span>)
meuse_grid <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">head</span>()</code></pre>
<pre><code>## # A tibble: 6 x 7
##        x      y part.a part.b   dist  soil ffreq
##    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 181180 333740      1      0 0          1     1
## 2 181140 333700      1      0 0          1     1
## 3 181180 333700      1      0 0.0122     1     1
## 4 181220 333700      1      0 0.0435     1     1
## 5 181100 333660      1      0 0          1     1
## 6 181140 333660      1      0 0.0122     1     1</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">meuse_grid <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_fixed</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size=</span><span class="fl">0.1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>()</code></pre>
<div class="figure" style="text-align: center"><span id="fig:meuse-grid"></span>
<img src="_main_files/figure-html/meuse-grid-1.png" alt="Grille pour la prédiction spatiale." width="100%" />
<p class="caption">
Figure 3.4: Grille pour la prédiction spatiale.
</p>
</div>
<p>Ramenons les coordonnées sur une même référence que celles utilisées pour la prédiction.</p>
<pre class="sourceCode r"><code class="sourceCode r">meuse_grid_coord &lt;-<span class="st"> </span>meuse_grid <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">st_as_sf</span>(<span class="dt">coords =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>), <span class="dt">crs =</span> <span class="dv">28992</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">st_transform</span>(<span class="st">&quot;+proj=longlat +datum=NAD83&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">st_coordinates</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">as_tibble</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">dist =</span> meuse_grid<span class="op">$</span>dist) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">rename</span>(<span class="dt">x =</span> <span class="st">&quot;X&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;Y&quot;</span>)</code></pre>
<p>Effectuons les prédictions des <em>ilr</em> sur la grille.</p>
<pre class="sourceCode r"><code class="sourceCode r">pred1 &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_CdCuPbZn.Fv, <span class="dt">newdata =</span> meuse_grid_coord)
pred2 &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_CdCu.PbZn, <span class="dt">newdata =</span> meuse_grid_coord)
pred3 &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_Cd.Cu, <span class="dt">newdata =</span> meuse_grid_coord)
pred4 &lt;-<span class="st"> </span><span class="kw">predict</span>(mod_Pb.Zn, <span class="dt">newdata =</span> meuse_grid_coord)</code></pre>
<p>Ces prédictions sont consignées dans un tableau.</p>
<pre class="sourceCode r"><code class="sourceCode r">meuse_pred &lt;-<span class="st"> </span>meuse_grid_coord <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">as_tibble</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">CdCuPbZn.Fv =</span> pred1,
         <span class="dt">CdCu.PbZn =</span> pred2,
         <span class="dt">Cd.Cu =</span> pred3,
         <span class="dt">Pb.Zn =</span> pred4)</code></pre>
<p>Ce tableau est utiliser pour effectuer la transformation inverse de l’ilr à la composition.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Transformation inverse</span>
meuse_pred_comp &lt;-<span class="st"> </span>meuse_pred <span class="op">%&gt;%</span>
<span class="st">  </span>dplyr<span class="op">::</span><span class="kw">select</span>(CdCuPbZn.Fv, CdCu.PbZn, Cd.Cu, Pb.Zn) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ilrInv</span>(., <span class="dt">V=</span>psi)

<span class="co"># En ppm</span>
meuse_pred_comp &lt;-<span class="st"> </span><span class="kw">unclass</span>(meuse_pred_comp) <span class="op">*</span><span class="st"> </span><span class="fl">1e6</span>

<span class="co"># En format tibble avec les bons noms</span>
meuse_pred_comp &lt;-<span class="st"> </span>meuse_pred_comp <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">as_tibble</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">rename</span>(<span class="st">&quot;cadmium&quot;</span> =<span class="st"> &quot;V1&quot;</span>,
         <span class="st">&quot;copper&quot;</span> =<span class="st"> &quot;V2&quot;</span>,
         <span class="st">&quot;lead&quot;</span> =<span class="st"> &quot;V3&quot;</span>,
         <span class="st">&quot;zinc&quot;</span> =<span class="st"> &quot;V4&quot;</span>,
         <span class="st">&quot;Fv&quot;</span> =<span class="st"> &quot;V5&quot;</span>)

<span class="co"># Fusionner avec le tableau de prédiction</span>
meuse_pred_comp &lt;-<span class="st"> </span><span class="kw">bind_cols</span>(meuse_pred, meuse_pred_comp)</code></pre>
<p>Enfin, nous pouvons projeter les résultats sur notre carte pour chaque point de la grille.</p>
<pre class="sourceCode r"><code class="sourceCode r">gg_cd &lt;-<span class="st"> </span><span class="kw">ggmap</span>(meuse_map) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> meuse_pred_comp, <span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">colour =</span> cadmium)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> meuse_coord, <span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">size =</span> cadmium), <span class="dt">shape =</span> <span class="dv">1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_colour_viridis_c</span>(<span class="dt">option =</span> <span class="st">&quot;inferno&quot;</span>, <span class="dt">direction =</span> <span class="dv">-1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>()
gg_cu &lt;-<span class="st"> </span><span class="kw">ggmap</span>(meuse_map) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> meuse_pred_comp, <span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">colour =</span> copper)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> meuse_coord, <span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">size =</span> copper), <span class="dt">shape =</span> <span class="dv">1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_colour_viridis_c</span>(<span class="dt">option =</span> <span class="st">&quot;inferno&quot;</span>, <span class="dt">direction =</span> <span class="dv">-1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>()
gg_pb &lt;-<span class="st"> </span><span class="kw">ggmap</span>(meuse_map) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> meuse_pred_comp, <span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">colour =</span> lead)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> meuse_coord, <span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">size =</span> lead), <span class="dt">shape =</span> <span class="dv">1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_colour_viridis_c</span>(<span class="dt">option =</span> <span class="st">&quot;inferno&quot;</span>, <span class="dt">direction =</span> <span class="dv">-1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>()
gg_zn &lt;-<span class="st"> </span><span class="kw">ggmap</span>(meuse_map) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> meuse_pred_comp, <span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">colour =</span> zinc)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> meuse_coord, <span class="kw">aes</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">size =</span> zinc), <span class="dt">shape =</span> <span class="dv">1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_colour_viridis_c</span>(<span class="dt">option =</span> <span class="st">&quot;inferno&quot;</span>, <span class="dt">direction =</span> <span class="dv">-1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>()

cowplot<span class="op">::</span><span class="kw">plot_grid</span>(gg_cd, gg_cu, gg_pb, gg_zn, <span class="dt">ncol =</span> <span class="dv">2</span>)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:meuse-pred"></span>
<img src="_main_files/figure-html/meuse-pred-1.png" alt="Prédiction spatiale des métaux lourds sur une rive de la rivière Meuse." width="100%" />
<p class="caption">
Figure 3.5: Prédiction spatiale des métaux lourds sur une rive de la rivière Meuse.
</p>
</div>
<p><img src="https://media.giphy.com/media/wFxEA22DwZUmk/giphy.gif" style="display: block; margin: auto;" /></p>
<p>Tu as raison, Bugs. Ça suffit pour aujourd’hui.</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="les-biostats-compositionnelles.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="liens-utiles.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
